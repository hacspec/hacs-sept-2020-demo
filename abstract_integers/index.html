<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="API documentation for the Rust `abstract_integers` crate."><meta name="keywords" content="rust, rustlang, rust-lang, abstract_integers"><title>abstract_integers - Rust</title><link rel="stylesheet" type="text/css" href="../normalize.css"><link rel="stylesheet" type="text/css" href="../rustdoc.css" id="mainThemeStyle"><link rel="stylesheet" type="text/css" href="../light.css"  id="themeStyle"><link rel="stylesheet" type="text/css" href="../dark.css" disabled ><link rel="stylesheet" type="text/css" href="../ayu.css" disabled ><script src="../storage.js"></script><noscript><link rel="stylesheet" href="../noscript.css"></noscript><link rel="shortcut icon" href="../favicon.ico"><style type="text/css">#crate-search{background-image:url("../down-arrow.svg");}</style></head><body class="rustdoc mod"><!--[if lte IE 8]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="sidebar"><div class="sidebar-menu">&#9776;</div><a href='../abstract_integers/index.html'><div class='logo-container rust-logo'><img src='../rust-logo.png' alt='logo'></div></a><p class='location'>Crate abstract_integers</p><div class='block version'><p>Version 0.1.4</p></div><div class="sidebar-elems"><a id='all-types' href='all.html'><p>See all abstract_integers's items</p></a><div class="block items"><ul><li><a href="#modules">Modules</a></li><li><a href="#macros">Macros</a></li><li><a href="#structs">Structs</a></li><li><a href="#enums">Enums</a></li><li><a href="#traits">Traits</a></li><li><a href="#functions">Functions</a></li></ul></div><p class='location'></p><script>window.sidebarCurrent = {name: 'abstract_integers', ty: 'mod', relpath: '../'};</script></div></nav><div class="theme-picker"><button id="theme-picker" aria-label="Pick another theme!"><img src="../brush.svg" width="18" alt="Pick another theme!"></button><div id="theme-choices"></div></div><script src="../theme.js"></script><nav class="sub"><form class="search-form"><div class="search-container"><div><select id="crate-search"><option value="All crates">All crates</option></select><input class="search-input" name="search" disabled autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"></div><span class="help-button">?</span>
                <a id="settings-menu" href="../settings.html"><img src="../wheel.svg" width="18" alt="Change settings"></a></div></form></nav><section id="main" class="content"><h1 class='fqn'><span class='out-of-band'><span id='render-detail'><a id="toggle-all-docs" href="javascript:void(0)" title="collapse all docs">[<span class='inner'>&#x2212;</span>]</a></span><a class='srclink' href='../src/abstract_integers/lib.rs.html#1-71' title='goto source code'>[src]</a></span><span class='in-band'>Crate <a class="mod" href=''>abstract_integers</a></span></h1><div class='docblock'><p>This crate defines specification-friendly natural integers with an upper bound. Operations on
these integers can be defined as modular (modulo the upper bound) or regular (with a panic
on underflow or overflow).</p>
<p>As each integer gets its own Rust type, the compiler detects and prevent any mixing between
all the diffent integers you would have defined.</p>
<h1 id="defining-a-new-integer-type" class="section-header"><a href="#defining-a-new-integer-type">Defining a new integer type</a></h1>
<p>Here is the macro used to defined the <code>SizeNatExample</code> type of this crate:</p>

<div class='information'><div class='tooltip ignore'>ⓘ<span class='tooltiptext'>This example is not tested</span></div></div><div class="example-wrap"><pre class="rust rust-example-rendered ignore">
<span class="macro">define_abstract_integer_checked</span><span class="macro">!</span>(<span class="ident">SizeNatExample</span>, <span class="number">64</span>);</pre></div>
<p><code>SizeNat</code> is the name of the newly-created type. <code>64</code> is the number of bits of the machine
representation of the type. From the number of bits is derived an upper bound for the integer
for which all operations are checked for overflow.</p>
<p>The resulting integer type is copyable, and supports addition, substraction, multiplication,
integer division, remainder, comparison and equality. The <code>from_literal</code> method allows you to
convert integer literals into your new type.</p>
<h1 id="refining-an-integer-type-for-modular-arithmetic" class="section-header"><a href="#refining-an-integer-type-for-modular-arithmetic">Refining an integer type for modular arithmetic</a></h1>
<p>On top of a previously defined abstract integer, you can define another type that lets you
implement modular arithmetic. For instance, this crate defines the arithmetic field over the
9th Mersenne prime with:</p>

<div class='information'><div class='tooltip ignore'>ⓘ<span class='tooltiptext'>This example is not tested</span></div></div><div class="example-wrap"><pre class="rust rust-example-rendered ignore">
<span class="macro">define_refined_modular_integer</span><span class="macro">!</span>(
   <span class="ident">SizeNatFieldExample</span>,
   <span class="ident">SizeNatExample</span>,
   <span class="ident">SizeNatExample</span>::<span class="ident">pow2</span>(<span class="number">61</span>) <span class="op">-</span> <span class="ident">SizeNatExample</span>::<span class="ident">from_literal</span>(<span class="number">1</span>)
);</pre></div>
<p>The first argument of this new macro is the name of the newly defined refined type. The second
argument is the name of the base abstract integer that will act as the representation. The
third example is the modulo for all operations, defined as a value of the base type.</p>
<h1 id="example" class="section-header"><a href="#example">Example</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">abstract_integers</span>::<span class="kw-2">*</span>;
 
<span class="macro">abstract_public_nat_mod</span><span class="macro">!</span>(<span class="ident">SizeNatFieldExample</span>, <span class="ident">SizeNatExample</span>, <span class="number">64</span>, <span class="string">&quot;1fffffffffffffff&quot;</span>);
 
<span class="kw">let</span> <span class="ident">x1</span> <span class="op">=</span> <span class="ident">SizeNatExample</span>::<span class="ident">from_literal</span>(<span class="number">687165654266415</span>);
<span class="kw">let</span> <span class="ident">x2</span> <span class="op">=</span> <span class="ident">SizeNatExample</span>::<span class="ident">from_literal</span>(<span class="number">4298832000156</span>);
<span class="kw">let</span> <span class="ident">x3</span> <span class="op">=</span> <span class="ident">x1</span> <span class="op">+</span> <span class="ident">x2</span>;
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">SizeNatExample</span>::<span class="ident">from_literal</span>(<span class="number">691464486266571</span>), <span class="ident">x3</span>);
<span class="kw">let</span> <span class="ident">x4</span> <span class="op">=</span> <span class="ident">SizeNatExample</span>::<span class="ident">from_literal</span>(<span class="number">8151084996540</span>);
<span class="kw">let</span> <span class="ident">x5</span> <span class="op">=</span> <span class="ident">x3</span> <span class="op">-</span> <span class="ident">x4</span>;
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">SizeNatExample</span>::<span class="ident">from_literal</span>(<span class="number">683313401270031</span>), <span class="ident">x5</span>.<span class="ident">into</span>());
<span class="kw">let</span> <span class="ident">x6</span> <span class="op">=</span> <span class="ident">x5</span> <span class="op">/</span> <span class="ident">SizeNatExample</span>::<span class="ident">from_literal</span>(<span class="number">1541654268</span>);
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">SizeNatExample</span>::<span class="ident">from_literal</span>(<span class="number">443233</span>), <span class="ident">x6</span>.<span class="ident">into</span>());
<span class="kw">let</span> <span class="ident">x7</span> : <span class="ident">SizeNatFieldExample</span> <span class="op">=</span> <span class="ident">SizeNatFieldExample</span>::<span class="ident">from_literal</span>(<span class="number">2305843009213693951</span>) <span class="op">+</span> <span class="ident">x6</span>.<span class="ident">into</span>();
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">x7</span>, <span class="ident">x6</span>.<span class="ident">into</span>());</pre></div>
</div><h2 id='modules' class='section-header'><a href="#modules">Modules</a></h2>
<table><tr class='module-item'><td><a class="mod" href="abstract_int/index.html" title='abstract_integers::abstract_int mod'>abstract_int</a></td><td class='docblock-short'></td></tr><tr class='module-item'><td><a class="mod" href="nat_mod/index.html" title='abstract_integers::nat_mod mod'>nat_mod</a></td><td class='docblock-short'></td></tr><tr class='module-item'><td><a class="mod" href="traits/index.html" title='abstract_integers::traits mod'>traits</a></td><td class='docblock-short'></td></tr></table><h2 id='macros' class='section-header'><a href="#macros">Macros</a></h2>
<table><tr class='module-item'><td><a class="macro" href="macro.abstract_int.html" title='abstract_integers::abstract_int macro'>abstract_int</a></td><td class='docblock-short'></td></tr><tr class='module-item'><td><a class="macro" href="macro.abstract_nat_mod.html" title='abstract_integers::abstract_nat_mod macro'>abstract_nat_mod</a></td><td class='docblock-short'></td></tr><tr class='module-item'><td><a class="macro" href="macro.abstract_public.html" title='abstract_integers::abstract_public macro'>abstract_public</a></td><td class='docblock-short'></td></tr><tr class='module-item'><td><a class="macro" href="macro.abstract_public_modular_integer.html" title='abstract_integers::abstract_public_modular_integer macro'>abstract_public_modular_integer</a></td><td class='docblock-short'></td></tr><tr class='module-item'><td><a class="macro" href="macro.abstract_public_nat_mod.html" title='abstract_integers::abstract_public_nat_mod macro'>abstract_public_nat_mod</a></td><td class='docblock-short'></td></tr><tr class='module-item'><td><a class="macro" href="macro.abstract_secret.html" title='abstract_integers::abstract_secret macro'>abstract_secret</a></td><td class='docblock-short'></td></tr><tr class='module-item'><td><a class="macro" href="macro.abstract_secret_modular_integer.html" title='abstract_integers::abstract_secret_modular_integer macro'>abstract_secret_modular_integer</a></td><td class='docblock-short'></td></tr><tr class='module-item'><td><a class="macro" href="macro.abstract_signed.html" title='abstract_integers::abstract_signed macro'>abstract_signed</a></td><td class='docblock-short'></td></tr><tr class='module-item'><td><a class="macro" href="macro.abstract_signed_public_integer.html" title='abstract_integers::abstract_signed_public_integer macro'>abstract_signed_public_integer</a></td><td class='docblock-short'></td></tr><tr class='module-item'><td><a class="macro" href="macro.abstract_signed_secret_integer.html" title='abstract_integers::abstract_signed_secret_integer macro'>abstract_signed_secret_integer</a></td><td class='docblock-short'></td></tr><tr class='module-item'><td><a class="macro" href="macro.abstract_unsigned.html" title='abstract_integers::abstract_unsigned macro'>abstract_unsigned</a></td><td class='docblock-short'></td></tr><tr class='module-item'><td><a class="macro" href="macro.abstract_unsigned_public_integer.html" title='abstract_integers::abstract_unsigned_public_integer macro'>abstract_unsigned_public_integer</a></td><td class='docblock-short'></td></tr><tr class='module-item'><td><a class="macro" href="macro.abstract_unsigned_secret_integer.html" title='abstract_integers::abstract_unsigned_secret_integer macro'>abstract_unsigned_secret_integer</a></td><td class='docblock-short'></td></tr><tr class='module-item'><td><a class="macro" href="macro.define_abstract_integer_checked.html" title='abstract_integers::define_abstract_integer_checked macro'>define_abstract_integer_checked</a></td><td class='docblock-short'><p>Defines a bounded natural integer with regular arithmetic operations, checked for overflow
and underflow.</p>
</td></tr><tr class='module-item'><td><a class="macro" href="macro.define_refined_modular_integer.html" title='abstract_integers::define_refined_modular_integer macro'>define_refined_modular_integer</a></td><td class='docblock-short'><p>Defines a bounded natural integer with modular arithmetic operations</p>
</td></tr><tr class='module-item'><td><a class="macro" href="macro.modular_integer.html" title='abstract_integers::modular_integer macro'>modular_integer</a></td><td class='docblock-short'></td></tr></table><h2 id='structs' class='section-header'><a href="#structs">Structs</a></h2>
<table><tr class='module-item'><td><a class="struct" href="struct.BigInt.html" title='abstract_integers::BigInt struct'>BigInt</a></td><td class='docblock-short'><p>A big signed integer type.</p>
</td></tr><tr class='module-item'><td><a class="struct" href="struct.BigUint.html" title='abstract_integers::BigUint struct'>BigUint</a></td><td class='docblock-short'><p>A big unsigned integer type.</p>
</td></tr><tr class='module-item'><td><a class="struct" href="struct.ParseIntError.html" title='abstract_integers::ParseIntError struct'>ParseIntError</a></td><td class='docblock-short'><p>An error which can be returned when parsing an integer.</p>
</td></tr><tr class='module-item'><td><a class="struct" href="struct.Range.html" title='abstract_integers::Range struct'>Range</a></td><td class='docblock-short'><p>A (half-open) range bounded inclusively below and exclusively above
(<code>start..end</code>).</p>
</td></tr><tr class='module-item'><td><a class="struct" href="struct.RangeFrom.html" title='abstract_integers::RangeFrom struct'>RangeFrom</a></td><td class='docblock-short'><p>A range only bounded inclusively below (<code>start..</code>).</p>
</td></tr><tr class='module-item'><td><a class="struct" href="struct.RangeFull.html" title='abstract_integers::RangeFull struct'>RangeFull</a></td><td class='docblock-short'><p>An unbounded range (<code>..</code>).</p>
</td></tr><tr class='module-item'><td><a class="struct" href="struct.RangeInclusive.html" title='abstract_integers::RangeInclusive struct'>RangeInclusive</a></td><td class='docblock-short'><p>A range bounded inclusively below and above (<code>start..=end</code>).</p>
</td></tr><tr class='module-item'><td><a class="struct" href="struct.RangeTo.html" title='abstract_integers::RangeTo struct'>RangeTo</a></td><td class='docblock-short'><p>A range only bounded exclusively above (<code>..end</code>).</p>
</td></tr><tr class='module-item'><td><a class="struct" href="struct.RangeToInclusive.html" title='abstract_integers::RangeToInclusive struct'>RangeToInclusive</a></td><td class='docblock-short'><p>A range only bounded inclusively above (<code>..=end</code>).</p>
</td></tr></table><h2 id='enums' class='section-header'><a href="#enums">Enums</a></h2>
<table><tr class='module-item'><td><a class="enum" href="enum.Bound.html" title='abstract_integers::Bound enum'>Bound</a></td><td class='docblock-short'><p>An endpoint of a range of keys.</p>
</td></tr><tr class='module-item'><td><a class="enum" href="enum.Ordering.html" title='abstract_integers::Ordering enum'>Ordering</a></td><td class='docblock-short'><p>An <code>Ordering</code> is the result of a comparison between two values.</p>
</td></tr><tr class='unstable module-item'><td><a class="enum" href="enum.ControlFlow.html" title='abstract_integers::ControlFlow enum'>ControlFlow</a></td><td class='docblock-short'><span class="stab unstable" title="">Experimental</span><p>Used to make try_fold closures more like normal loops</p>
</td></tr><tr class='unstable module-item'><td><a class="enum" href="enum.GeneratorState.html" title='abstract_integers::GeneratorState enum'>GeneratorState</a></td><td class='docblock-short'><span class="stab unstable" title="">Experimental</span><p>The result of a generator resumption.</p>
</td></tr><tr class='module-item'><td><a class="enum" href="enum.Sign.html" title='abstract_integers::Sign enum'>Sign</a></td><td class='docblock-short'><p>A Sign is a <code>BigInt</code>'s composing element.</p>
</td></tr></table><h2 id='traits' class='section-header'><a href="#traits">Traits</a></h2>
<table><tr class='module-item'><td><a class="trait" href="trait.Add.html" title='abstract_integers::Add trait'>Add</a></td><td class='docblock-short'><p>The addition operator <code>+</code>.</p>
</td></tr><tr class='module-item'><td><a class="trait" href="trait.AddAssign.html" title='abstract_integers::AddAssign trait'>AddAssign</a></td><td class='docblock-short'><p>The addition assignment operator <code>+=</code>.</p>
</td></tr><tr class='module-item'><td><a class="trait" href="trait.BitAnd.html" title='abstract_integers::BitAnd trait'>BitAnd</a></td><td class='docblock-short'><p>The bitwise AND operator <code>&amp;</code>.</p>
</td></tr><tr class='module-item'><td><a class="trait" href="trait.BitAndAssign.html" title='abstract_integers::BitAndAssign trait'>BitAndAssign</a></td><td class='docblock-short'><p>The bitwise AND assignment operator <code>&amp;=</code>.</p>
</td></tr><tr class='module-item'><td><a class="trait" href="trait.BitOr.html" title='abstract_integers::BitOr trait'>BitOr</a></td><td class='docblock-short'><p>The bitwise OR operator <code>|</code>.</p>
</td></tr><tr class='module-item'><td><a class="trait" href="trait.BitOrAssign.html" title='abstract_integers::BitOrAssign trait'>BitOrAssign</a></td><td class='docblock-short'><p>The bitwise OR assignment operator <code>|=</code>.</p>
</td></tr><tr class='module-item'><td><a class="trait" href="trait.BitXor.html" title='abstract_integers::BitXor trait'>BitXor</a></td><td class='docblock-short'><p>The bitwise XOR operator <code>^</code>.</p>
</td></tr><tr class='module-item'><td><a class="trait" href="trait.BitXorAssign.html" title='abstract_integers::BitXorAssign trait'>BitXorAssign</a></td><td class='docblock-short'><p>The bitwise XOR assignment operator <code>^=</code>.</p>
</td></tr><tr class='module-item'><td><a class="trait" href="trait.CheckedSub.html" title='abstract_integers::CheckedSub trait'>CheckedSub</a></td><td class='docblock-short'><p>Performs subtraction that returns <code>None</code> instead of wrapping around on underflow.</p>
</td></tr><tr class='module-item'><td><a class="trait" href="trait.Deref.html" title='abstract_integers::Deref trait'>Deref</a></td><td class='docblock-short'><p>Used for immutable dereferencing operations, like <code>*v</code>.</p>
</td></tr><tr class='module-item'><td><a class="trait" href="trait.DerefMut.html" title='abstract_integers::DerefMut trait'>DerefMut</a></td><td class='docblock-short'><p>Used for mutable dereferencing operations, like in <code>*v = 1;</code>.</p>
</td></tr><tr class='module-item'><td><a class="trait" href="trait.Div.html" title='abstract_integers::Div trait'>Div</a></td><td class='docblock-short'><p>The division operator <code>/</code>.</p>
</td></tr><tr class='module-item'><td><a class="trait" href="trait.DivAssign.html" title='abstract_integers::DivAssign trait'>DivAssign</a></td><td class='docblock-short'><p>The division assignment operator <code>/=</code>.</p>
</td></tr><tr class='module-item'><td><a class="trait" href="trait.Drop.html" title='abstract_integers::Drop trait'>Drop</a></td><td class='docblock-short'><p>Custom code within the destructor.</p>
</td></tr><tr class='module-item'><td><a class="trait" href="trait.Fn.html" title='abstract_integers::Fn trait'>Fn</a></td><td class='docblock-short'><p>The version of the call operator that takes an immutable receiver.</p>
</td></tr><tr class='module-item'><td><a class="trait" href="trait.FnMut.html" title='abstract_integers::FnMut trait'>FnMut</a></td><td class='docblock-short'><p>The version of the call operator that takes a mutable receiver.</p>
</td></tr><tr class='module-item'><td><a class="trait" href="trait.FnOnce.html" title='abstract_integers::FnOnce trait'>FnOnce</a></td><td class='docblock-short'><p>The version of the call operator that takes a by-value receiver.</p>
</td></tr><tr class='module-item'><td><a class="trait" href="trait.Index.html" title='abstract_integers::Index trait'>Index</a></td><td class='docblock-short'><p>Used for indexing operations (<code>container[index]</code>) in immutable contexts.</p>
</td></tr><tr class='module-item'><td><a class="trait" href="trait.IndexMut.html" title='abstract_integers::IndexMut trait'>IndexMut</a></td><td class='docblock-short'><p>Used for indexing operations (<code>container[index]</code>) in mutable contexts.</p>
</td></tr><tr class='module-item'><td><a class="trait" href="trait.Mul.html" title='abstract_integers::Mul trait'>Mul</a></td><td class='docblock-short'><p>The multiplication operator <code>*</code>.</p>
</td></tr><tr class='module-item'><td><a class="trait" href="trait.MulAssign.html" title='abstract_integers::MulAssign trait'>MulAssign</a></td><td class='docblock-short'><p>The multiplication assignment operator <code>*=</code>.</p>
</td></tr><tr class='module-item'><td><a class="trait" href="trait.Neg.html" title='abstract_integers::Neg trait'>Neg</a></td><td class='docblock-short'><p>The unary negation operator <code>-</code>.</p>
</td></tr><tr class='module-item'><td><a class="trait" href="trait.Not.html" title='abstract_integers::Not trait'>Not</a></td><td class='docblock-short'><p>The unary logical negation operator <code>!</code>.</p>
</td></tr><tr class='module-item'><td><a class="trait" href="trait.One.html" title='abstract_integers::One trait'>One</a></td><td class='docblock-short'><p>Defines a multiplicative identity element for <code>Self</code>.</p>
</td></tr><tr class='module-item'><td><a class="trait" href="trait.RangeBounds.html" title='abstract_integers::RangeBounds trait'>RangeBounds</a></td><td class='docblock-short'><p><code>RangeBounds</code> is implemented by Rust's built-in range types, produced
by range syntax like <code>..</code>, <code>a..</code>, <code>..b</code>, <code>..=c</code>, <code>d..e</code>, or <code>f..=g</code>.</p>
</td></tr><tr class='module-item'><td><a class="trait" href="trait.Rem.html" title='abstract_integers::Rem trait'>Rem</a></td><td class='docblock-short'><p>The remainder operator <code>%</code>.</p>
</td></tr><tr class='module-item'><td><a class="trait" href="trait.RemAssign.html" title='abstract_integers::RemAssign trait'>RemAssign</a></td><td class='docblock-short'><p>The remainder assignment operator <code>%=</code>.</p>
</td></tr><tr class='module-item'><td><a class="trait" href="trait.Shl.html" title='abstract_integers::Shl trait'>Shl</a></td><td class='docblock-short'><p>The left shift operator <code>&lt;&lt;</code>. Note that because this trait is implemented
for all integer types with multiple right-hand-side types, Rust's type
checker has special handling for <code>_ &lt;&lt; _</code>, setting the result type for
integer operations to the type of the left-hand-side operand. This means
that though <code>a &lt;&lt; b</code> and <code>a.shl(b)</code> are one and the same from an evaluation
standpoint, they are different when it comes to type inference.</p>
</td></tr><tr class='module-item'><td><a class="trait" href="trait.ShlAssign.html" title='abstract_integers::ShlAssign trait'>ShlAssign</a></td><td class='docblock-short'><p>The left shift assignment operator <code>&lt;&lt;=</code>.</p>
</td></tr><tr class='module-item'><td><a class="trait" href="trait.Shr.html" title='abstract_integers::Shr trait'>Shr</a></td><td class='docblock-short'><p>The right shift operator <code>&gt;&gt;</code>. Note that because this trait is implemented
for all integer types with multiple right-hand-side types, Rust's type
checker has special handling for <code>_ &gt;&gt; _</code>, setting the result type for
integer operations to the type of the left-hand-side operand. This means
that though <code>a &gt;&gt; b</code> and <code>a.shr(b)</code> are one and the same from an evaluation
standpoint, they are different when it comes to type inference.</p>
</td></tr><tr class='module-item'><td><a class="trait" href="trait.ShrAssign.html" title='abstract_integers::ShrAssign trait'>ShrAssign</a></td><td class='docblock-short'><p>The right shift assignment operator <code>&gt;&gt;=</code>.</p>
</td></tr><tr class='module-item'><td><a class="trait" href="trait.Sub.html" title='abstract_integers::Sub trait'>Sub</a></td><td class='docblock-short'><p>The subtraction operator <code>-</code>.</p>
</td></tr><tr class='module-item'><td><a class="trait" href="trait.SubAssign.html" title='abstract_integers::SubAssign trait'>SubAssign</a></td><td class='docblock-short'><p>The subtraction assignment operator <code>-=</code>.</p>
</td></tr><tr class='unstable module-item'><td><a class="trait" href="trait.CoerceUnsized.html" title='abstract_integers::CoerceUnsized trait'>CoerceUnsized</a></td><td class='docblock-short'><span class="stab unstable" title="">Experimental</span><p>Trait that indicates that this is a pointer or a wrapper for one,
where unsizing can be performed on the pointee.</p>
</td></tr><tr class='unstable module-item'><td><a class="trait" href="trait.DispatchFromDyn.html" title='abstract_integers::DispatchFromDyn trait'>DispatchFromDyn</a></td><td class='docblock-short'><span class="stab unstable" title="">Experimental</span><p>This is used for object safety, to check that a method's receiver type can be dispatched on.</p>
</td></tr><tr class='unstable module-item'><td><a class="trait" href="trait.Generator.html" title='abstract_integers::Generator trait'>Generator</a></td><td class='docblock-short'><span class="stab unstable" title="">Experimental</span><p>The trait implemented by builtin generator types.</p>
</td></tr><tr class='unstable module-item'><td><a class="trait" href="trait.Try.html" title='abstract_integers::Try trait'>Try</a></td><td class='docblock-short'><span class="stab unstable" title="">Experimental</span><p>A trait for customizing the behavior of the <code>?</code> operator.</p>
</td></tr><tr class='module-item'><td><a class="trait" href="trait.Zero.html" title='abstract_integers::Zero trait'>Zero</a></td><td class='docblock-short'><p>Defines an additive identity element for <code>Self</code>.</p>
</td></tr></table><h2 id='functions' class='section-header'><a href="#functions">Functions</a></h2>
<table><tr class='module-item'><td><a class="fn" href="fn.one.html" title='abstract_integers::one fn'>one</a></td><td class='docblock-short'><p>Returns the multiplicative identity, <code>1</code>.</p>
</td></tr><tr class='module-item'><td><a class="fn" href="fn.zero.html" title='abstract_integers::zero fn'>zero</a></td><td class='docblock-short'><p>Returns the additive identity, <code>0</code>.</p>
</td></tr></table></section><section id="search" class="content hidden"></section><section class="footer"></section><script>window.rootPath = "../";window.currentCrate = "abstract_integers";</script><script src="../main.js"></script><script defer src="../search-index.js"></script></body></html>